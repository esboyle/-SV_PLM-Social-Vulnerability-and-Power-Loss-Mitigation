import pandas as pd
import numpy as np
import random
from scipy.optimize import minimize
import networkx as nx
import math
from gurobipy import *  # Liscence needed, free academic liscence available at https://www.gurobi.com/

# =====================================#
# Component Based Event Simulation
# Stochastic Power Network Failure Under Extreme Weather Events
# =====================================#
#
# Modeling Components:
#
# Weather Event Generation:
#   Simulates maximum windspeed exerted on each transmission line of network
#
# Fragility Model:
#   Simulates breakage for each transmission line of the network
#    # Based on fragility of transmission towers reported in:
#   Panteli M, Pickering C, Wilkinson S, Dawson R, Mancarella P. Power System Resilience to 
#   Extreme Weather: Fragility Modelling, Probabilistic Impact Assessment, and Adaptation 
#   Measures. IEEE Trans Power Syst 2017 32:1-1. doi:10.1109/TPWRS.2016.2641463.
#    # and further available from:
#   Bennett, Jeffrey A.; DeCarolis, Joseph F.; Clarens, Andres F., 2020, "Model and data for 
#   "Extending energy system modelling to include extreme weather risks and application to hurricane 
#   events in Puerto Rico"", https://doi.org/10.18130/V3/QB0NPX, University of Virginia Dataverse, V1 
#
# Stochastic Network Breakage:
#   Simulates breakages of network links
#
# Power Flow Model
#   Simulates power flow through any given network
#
# Social Vulnerability Model
#   Estimates impact of network loss on social vulnerability based on network power loss
#
#
# Special thanks to  Ali Ganji for contributions to this code
#=====================================#





# =====================================#
# INFER DISTANCES
# =====================================#  
def distances(nodes_file ='NetworkNodes.csv', links_file = 'NetworkLinks.csv'):
    
    """This function takes csv files with data on power network links and nodes and
    returns a list of the haversine distances between each pair of nodes in the network. 
    Used to infer length of transmission line (and subsequnt number of towers) when exact length 
    or number of towers is not known empirically.
    
    Input: nodes_file: containing information about the network nodes
        links_file: containing information about the network links

    Output: lengths: a pandas series lising the length of each network link in miles."""

    # load data
    nodes = pd.read_csv(nodes_file)
    links = pd.read_csv(links_file)
    L = links.shape[0] # number of transmission lines


    lengths = []
    for i in range(L):
        
        # determine latitude and longitude of the line
        lon1 = nodes['Longitude'].iloc[links["From_Node"].iloc[i]]
        lat1 = nodes['Latitude'].iloc[links["From_Node"].iloc[i]]
        lon2 = nodes['Longitude'].iloc[links["To_Node"].iloc[i]]
        lat2 = nodes['Latitude'].iloc[links["To_Node"].iloc[i]]
        
        
        # convert decimal degrees to radians
        lon1, lat1, lon2, lat2 = map(math.radians, [lon1, lat1, lon2, lat2])
    
        # haversine distance formula
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = math.sin(dlat / 2) ** 2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
        c = 2 * math.asin(math.sqrt(a))
        r = 3956  # Radius of earth in miles
        lengths += [c * r]
        
    return pd.Series(lengths)







# =====================================#
# Weather Event Generation
# =====================================#  
def wind_generation(windspeed_file = 'HistoricalMaxWindspeeds.csv',
                    intersections_file = 'LineIntersections.csv',
                    breakable_links = np.array(range(12,92))
                    ):
    
    """This function uses historical storm data to simulate a new hurricane event, returning
    the maximum sustained windspeed exerted on each link in the network.
    
    Input: windspeed_file: a csv file of historical storms, giving max sustained windspeed in each geographic subregion
         intersections_file: csv file with one row for each network link (of interest) that gives which geographic
              subregions that link passes through.
          breakable_links: a list of the link indices of interest to simulate wind events for

    Output: a pandas series lising the maximum sustained windspeed exerted on each network link."""
   
    
    
    # load data
    windspeeds = pd.read_csv(windspeed_file, index_col = 0)   
    windspeeds.index = [str(x) for x in windspeeds.index]
    intersections = pd.read_csv(intersections_file, index_col = 0) 

    
    # generate wind in each geographic region
    num_events = windspeeds.shape[1]    
    new_windspeed = pd.Series(0, index = windspeeds.index) # initialize
    
    for j in windspeeds.index:
        new_windspeed.loc[j] = windspeeds.loc[j][random.randint(0,num_events-1)]
    
    
    
    # determine maximum windspeed exerted on each transmission line
    observed_winds = [] # initialize
    
    for k in breakable_links: 
        regions = list(intersections.columns[intersections.loc[k] ==1])
        max_wind = new_windspeed.loc[regions].max() 
        observed_winds += [max_wind]
            
    
    return pd.Series(observed_winds, index = breakable_links)








# =====================================#
# Fragility Model
#
# Based on fragility of transmission towers reported in:
#
#   Panteli M, Pickering C, Wilkinson S, Dawson R, Mancarella P. Power System Resilience to 
#   Extreme Weather: Fragility Modelling, Probabilistic Impact Assessment, and Adaptation 
#   Measures. IEEE Trans Power Syst 2017 32:1-1. doi:10.1109/TPWRS.2016.2641463.
#
# and further available from:
#
#   Bennett, Jeffrey A.; DeCarolis, Joseph F.; Clarens, Andres F., 2020, "Model and data for 
#   "Extending energy system modelling to include extreme weather risks and application to hurricane 
#   events in Puerto Rico"", https://doi.org/10.18130/V3/QB0NPX, University of Virginia Dataverse, V1 
#
# =====================================#  
def fragility(observed_winds,
              num_towers = 7*distances()[12:92], # assume 7 towers per mile
              scale_wind = 0.5144447 # default wind file is in knots
              ):
        
    
    """This function calculates the probability of failure for each transmission line given a realized storm.
    
    Input: observed_winds: a pandas series of maximum sustained windspeed observed for each network link
          num_towers: a pandas series of the number of towers along each network link (must be same length as array for
                                                                         windspeeds)
          scale_wind: a scaling factor to covert given windspeeds into m/s

    Output: fail_prob_link: a numpy array lising the probability of breakage for each network link."""
    
    
    wind_ms = observed_winds *0.5144447 # converts to m/s
    x = [41.16350883, 45.27810213, 50.51352572, 55.18578793, 59.48053428, 62.46734014, 66.01144875, 68.9942268,
            73.09673666, 76.82465998, 81.48447258, 86.51887172, 91.3679915, 96.21967444, 101.8216289, 107.6117921,
            114.3393371, 121.4440317, 127.8021164, 136.0327677, 142.0180967, 149.688882, 157.1725572]
    y = [0.003913894, 0.01369863, 0.033268102, 0.062622309, 0.109589041, 0.146771037, 0.205479452, 0.264187867,
            0.338551859, 0.414872798, 0.510763209, 0.604696673, 0.688845401, 0.759295499, 0.819960861, 0.874755382,
            0.919765166, 0.949119374, 0.968688845, 0.980430528, 0.992172211, 0.996086106, 1.0]
    fail_prob_tower = np.interp(wind_ms, x, y, left=0.0, right=1.0)
    fail_prob_link = 1-(1-fail_prob_tower)**num_towers

    return(fail_prob_link)
    
    
    
    
    
    
    
    
    

# =====================================#
# Network Breakage Model
# =====================================#      
def breakage(prob_fail_link,
              adj_file = 'adjacency.csv',
              links_file ='NetworkLinks.csv'):
    
    """This function simulates the failure of each link of the network. Only links indexed in 'prob_fail_link'
    will be simulated for failure
    
    Input: prob_fail_link: a pandas series of the probability of failure of each network link
          nodes_file: containing information about the network nodes
          links_file: containing information about the network links

    Output: newAdjacency: DataFrmae containing the adjacency matrix after network failiures
            broken: list indicating which network links broke."""
    
    
    links = pd.read_csv(links_file)
    newAdjacency = pd.read_csv(adj_file, header =None) # get original adjacency matrix
    broken = []
    
    for k in prob_fail_link.index: #Loop through links of the matrix elibible to break
    
        i = links['From_Node'][k] # The starting node (ROW of adj mats)
        j = links['To_Node'][k] # The ending node (COLUMN of adj mats)
  
            
        if random.uniform(0, 1)<=prob_fail_link[k] : # if we are breaking
            newAdjacency.iloc[i,j] = 0
            newAdjacency.iloc[j,i] = 0
            broken += [1]
        else: broken += [0]
            
    return(newAdjacency, broken)











# =====================================#
# Network Flow Model
# =====================================# 
def power_flow(adj_mat, nodes_file ='NetworkNodes.csv', links_file = 'NetworkLinks.csv'):
    """ This function takes the adjacency matrix of the (sub-)network of interest as input and returns 
    the supplied power at each municipality as well as flow matrix.
    Flow matrix is a matrix that gives the power flow over the link between each pair of the nodes. 
    This function formulates and solves a simple linear optimization model to generate the output.

    Input:
        adj_mat: adjacency matrix of the available sub-network
        nodes_file: containing information about the network nodes
        links_file: containing information about the network links

    output:
        power_supplied: a numpy array that gives the supplied power in each municipality
        flow_matrix: a numpay array that gives the flow between each pair of nodes in the network."""


    # Reading links and nodes datafarmes
    nodes = pd.read_csv(nodes_file)
    links = pd.read_csv(links_file)


    n = nodes.shape[0]
    l = links.shape[0]

    # Using the adjacency matrix to update the available links
    for i in range(l):
        origin = int(links.loc[i, 'From_Node'])
        destination = int(links.loc[i, 'To_Node'])
        if adj_mat.iloc[origin, destination] == 0:
            links.loc[i, 'Transmission_Capacity'] = 0

    # Reading optimization model parameters
    rd = {}
    cd = {}
    ur = {}
    uc = {}
    gc = {}
    for i in range(n):
        rd[i] = nodes["Regular_Demand"].iloc[i]
        cd[i] = nodes["Critical_Demand"].iloc[i]
        ur[i] = nodes["Unmet_Regular"].iloc[i]
        uc[i] = nodes["Unmet_Critical"].iloc[i]
        gc[i] = nodes["Generation_Capacity"].iloc[i]

    # Create optimization model
    m = Model()

    # Defining the decision variables
    ps = m.addVars((i) for i in range(n))
    pg = m.addVars([(i) for i in range(n)], 
                  lb=[0 for i in range(n)],
                   ub=[gc[i] for i in range(n)])

    pt_ub = np.zeros((n, n))
    for i in range(l):
        pt_ub[links["From_Node"].iloc[i], links["To_Node"].iloc[i]] = \
            links["Transmission_Capacity"].iloc[i]
        if links["Type"].iloc[i] == 2:
            pt_ub[links["To_Node"].iloc[i], links["From_Node"].iloc[i]] = links["Transmission_Capacity"].iloc[i]
    pt = m.addVars([(i, k) for i in range(n) for k in range(n)], lb=[0 for i in range(n) for k in range(n)], ub=pt_ub)

    # Adding model constraints
    m.addConstrs(quicksum(pt[k, i] for k in range(n)) +
                 pg[i] == ps[i] + quicksum(pt[i, k] for k in range(n)) for i in range(n))
    m.addConstrs(ps[i] <= ((rd[i] + cd[i])) for i in range(n))

    # Defining the objective function
    m.setObjective(quicksum((rd[i] + cd[i]) for i in range(n)) - quicksum(ps[i] for i in range(n)), GRB.MINIMIZE)

    # Solving the model and getting the optimal value of decision variables.
    m.update
    m.optimize()
    power_supplied = m.getAttr('x', ps).values()[62:138]
    flow_matrix = np.reshape(m.getAttr('x', pt).values(), (n, n))
    
    return power_supplied, flow_matrix









# =====================================#
# Social Vulnerability
# =====================================# 
def social_vuln(power_supplied, 
                a_list = [1,10],
                adj_file = 'adjacency.csv',
                svi_file = 'CDC_SoVI_2017.csv'
                ):
    """ This function takes the service level results and calculates the social impact at
    each subregion of interest.
    
    Input:
        power_supplied: the power available at each subregion of interest
        a_list: values of a to be used for VEWL calculation
        adj_file: file name/location for the original network adjacency matrix
        svi_file: file name/location for SOVI by subregion ID (here, FIPS)

    output:
        results: dataframe containing service level losses and impact scores for each
        subregion of interest."""
        
    adj = pd.read_csv(adj_file, header =None)
    social_vuln = pd.read_csv(svi_file).sort_values('region_id').set_index('region_id')
    svi_weights = social_vuln['SoVI_2017']/np.sum(social_vuln['SoVI_2017'])

    # get original power supply from network
    originalPowerNet = nx.from_numpy_matrix(adj.to_numpy(), create_using=nx.DiGraph)
    originalSupply, originalFlow = power_flow(adj, nodes_file, links_file)
    originalTotSupply = sum(originalSupply)
    
    
    sll = (np.array(originalSupply)-np.array(power_supplied))
    vwl = (np.array(originalSupply)-np.array(power_supplied))*svi_weights
    
    results = pd.DataFrame([list(svi_weights), originalSupply, sll,vwl]).transpose()
    results.index = social_vuln.index
    results.columns = ['SVI_Weights','Original_Supply','SLL', 'VWL']
    
    for a in a_list: #vulnerability exponentially weighted loss impact score
        vewl = (np.array(originalSupply)-np.array(power_supplied))*np.exp(a*svi_weights)
        results['VEWL'+str(a)] = list(vewl)
    
    
    return results




